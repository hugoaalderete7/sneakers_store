# Documentación: Uso de dispatch y createAsyncThunk en Redux Toolkit

## Pregunta inicial:
**¿Cómo usaría dispatch en este usersThunks.js?**

### Respuesta:
En un archivo como `usersThunks.js`, que probablemente contiene **thunks** para manejar acciones asíncronas en Redux, usarías `dispatch` para enviar acciones al store. Esto es común cuando trabajas con `redux-thunk` como middleware.

### Ejemplo básico de cómo usar `dispatch` en `usersThunks.js`

Supongamos que tienes un slice de Redux para manejar usuarios y quieres crear un thunk para obtener una lista de usuarios desde una API. Aquí está cómo usarías `dispatch`:

```javascript
import { createAsyncThunk } from '@reduxjs/toolkit';
import { setUsers, setLoading, setError } from './usersSlice'; // Acciones del slice

// Ejemplo de un thunk para obtener usuarios
export const fetchUsers = () => {
    return async (dispatch) => {
        dispatch(setLoading(true)); // Despacha una acción para indicar que está cargando

        try {
            const response = await fetch('https://api.example.com/users');
            const data = await response.json();

            dispatch(setUsers(data)); // Despacha una acción para guardar los usuarios en el estado
        } catch (error) {
            dispatch(setError(error.message)); // Despacha una acción para manejar errores
        } finally {
            dispatch(setLoading(false)); // Despacha una acción para indicar que terminó de cargar
        }
    };
};
```

---

## Pregunta:
**En el ejemplo con el createAsyncThunk, ¿dónde está la conexión con el slice.reducer?**

### Respuesta:
En el caso de `createAsyncThunk`, la conexión con el `slice.reducer` se realiza automáticamente gracias a Redux Toolkit.

### Explicación:
Cuando defines un thunk con `createAsyncThunk`, Redux Toolkit genera automáticamente tres tipos de acciones asociadas al ciclo de vida de la operación asíncrona:
- **`pending`**: Se despacha cuando la operación comienza.
- **`fulfilled`**: Se despacha cuando la operación se completa con éxito.
- **`rejected`**: Se despacha cuando la operación falla.

Por ejemplo, si defines un thunk así:
```javascript
export const fetchUsers = createAsyncThunk(
    'users/fetchUsers',
    async (_, { rejectWithValue }) => {
        try {
            const response = await fetch('https://api.example.com/users');
            if (!response.ok) {
                throw new Error('Error al obtener los usuarios');
            }
            return await response.json(); // Devuelve los datos
        } catch (error) {
            return rejectWithValue(error.message); // Maneja errores
        }
    }
);
```

Redux Toolkit generará automáticamente estas acciones:
- `users/fetchUsers/pending`
- `users/fetchUsers/fulfilled`
- `users/fetchUsers/rejected`

### Conexión con el `slice.reducer`:
En el slice correspondiente, puedes manejar estas acciones generadas automáticamente dentro del `extraReducers`. Aquí es donde se conecta el thunk con el `reducer`.

Ejemplo de un slice que maneja el thunk `fetchUsers`:
```javascript
import { createSlice } from '@reduxjs/toolkit';
import { fetchUsers } from './usersThunks';

const usersSlice = createSlice({
    name: 'users',
    initialState: {
        users: [],
        loading: false,
        error: null,
    },
    extraReducers: (builder) => {
        builder
            .addCase(fetchUsers.pending, (state) => {
                state.loading = true;
                state.error = null;
            })
            .addCase(fetchUsers.fulfilled, (state, action) => {
                state.loading = false;
                state.users = action.payload; // Actualiza el estado con los datos obtenidos
            })
            .addCase(fetchUsers.rejected, (state, action) => {
                state.loading = false;
                state.error = action.payload; // Guarda el error en el estado
            });
    },
});

export default usersSlice.reducer;
```

---

## Pregunta:
**Si en mi slice no tengo acciones síncronas, ¿la propiedad reducers no iría? ¿Solo iría extraReducers?**

### Respuesta:
¡Exacto! Si en tu slice no necesitas definir acciones síncronas, puedes omitir completamente la propiedad `reducers` y quedarte solo con `extraReducers`. Esto es válido porque `reducers` es opcional en un slice de Redux Toolkit.

### Ejemplo de un slice sin `reducers`:
Si solo estás manejando acciones asíncronas con `createAsyncThunk`, tu slice podría verse así:
```javascript
import { createSlice } from '@reduxjs/toolkit';
import { fetchUsers } from './usersThunks';

const usersSlice = createSlice({
    name: 'users',
    initialState: {
        users: [],
        loading: false,
        error: null,
    },
    extraReducers: (builder) => {
        builder
            .addCase(fetchUsers.pending, (state) => {
                state.loading = true;
                state.error = null;
            })
            .addCase(fetchUsers.fulfilled, (state, action) => {
                state.loading = false;
                state.users = action.payload;
            })
            .addCase(fetchUsers.rejected, (state, action) => {
                state.loading = false;
                state.error = action.payload;
            });
    },
});

export default usersSlice.reducer;
```

---

## Pregunta:
**¿Qué es lo recomendable o cuál sería la buena práctica, en los Thunk, usar createAsyncThunk o no usarlo? ¿O es lo mismo?**

### Respuesta:
La elección entre usar `createAsyncThunk` o escribir tus propios thunks manualmente depende de tus necesidades y preferencias, pero **usar `createAsyncThunk` es generalmente la mejor práctica** en la mayoría de los casos.

### Comparación:
#### **Ventajas de `createAsyncThunk`:**
- **Menos código repetitivo:** No necesitas definir manualmente las acciones (`pending`, `fulfilled`, `rejected`).
- **Manejo de errores integrado:** Puedes usar `rejectWithValue` para manejar errores de manera más clara.
- **Estandarización:** Proporciona una estructura consistente para manejar operaciones asíncronas.

#### **Ventajas de escribir thunks manualmente:**
- **Mayor flexibilidad:** Puedes despachar múltiples acciones dentro del thunk.
- **Control total:** Tienes control absoluto sobre cómo se manejan las acciones y el flujo de la lógica.

### Recomendación:
En la mayoría de los casos, **usar `createAsyncThunk` es la mejor práctica** porque:
- Reduce el código repetitivo.
- Proporciona una estructura clara y estandarizada.
- Se integra perfectamente con Redux Toolkit.

---

## Pregunta:
**Si en el Thunk debo crear las acciones para un CRUD, por ejemplo createUsers, readUsers, updateUser, deleteUser, ¿tengo que hacer 4 extraReducers o en el mismo, agregar .addCase?**

### Respuesta:
Si estás manejando un CRUD (crear, leer, actualizar, eliminar) con `createAsyncThunk`, lo más común y recomendable es crear un **thunk separado para cada operación** (`createUsers`, `readUsers`, `updateUser`, `deleteUser`) y luego manejar cada uno de ellos en el mismo `extraReducers` del slice correspondiente.

### Ejemplo completo:
#### **Definir los thunks:**
```javascript
import { createAsyncThunk } from '@reduxjs/toolkit';

// Crear un usuario
export const createUsers = createAsyncThunk(
    'users/createUsers',
    async (userData, { rejectWithValue }) => {
        try {
            const response = await fetch('https://api.example.com/users', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(userData),
            });
            if (!response.ok) throw new Error('Error al crear el usuario');
            return await response.json();
        } catch (error) {
            return rejectWithValue(error.message);
        }
    }
);

// Leer usuarios
export const readUsers = createAsyncThunk(
    'users/readUsers',
    async (_, { rejectWithValue }) => {
        try {
            const response = await fetch('https://api.example.com/users');
            if (!response.ok) throw new Error('Error al obtener los usuarios');
            return await response.json();
        } catch (error) {
            return rejectWithValue(error.message);
        }
    }
);

// Actualizar un usuario
export const updateUser = createAsyncThunk(
    'users/updateUser',
    async ({ id, userData }, { rejectWithValue }) => {
        try {
            const response = await fetch(`https://api.example.com/users/${id}`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(userData),
            });
            if (!response.ok) throw new Error('Error al actualizar el usuario');
            return await response.json();
        } catch (error) {
            return rejectWithValue(error.message);
        }
    }
);

// Eliminar un usuario
export const deleteUser = createAsyncThunk(
    'users/deleteUser',
    async (id, { rejectWithValue }) => {
        try {
            const response = await fetch(`https://api.example.com/users/${id}`, {
                method: 'DELETE',
            });
            if (!response.ok) throw new Error('Error al eliminar el usuario');
            return id; // Devuelve el ID del usuario eliminado
        } catch (error) {
            return rejectWithValue(error.message);
        }
    }
);
```

#### **Manejar los thunks en el slice:**
```javascript
import { createSlice } from '@reduxjs/toolkit';
import { createUsers, readUsers, updateUser, deleteUser } from './usersThunks';

const usersSlice = createSlice({
    name: 'users',
    initialState: {
        users: [],
        loading: false,
        error: null,
    },
    extraReducers: (builder) => {
        // Crear usuario
        builder
            .addCase(createUsers.pending, (state) => {
                state.loading = true;
                state.error = null;
            })
            .addCase(createUsers.fulfilled, (state, action) => {
                state.loading = false;
                state.users.push(action.payload);
            })
            .addCase(createUsers.rejected, (state, action) => {
                state.loading = false;
                state.error = action.payload;
            });

        // Leer usuarios
        builder
            .addCase(readUsers.pending, (state) => {
                state.loading = true;
                state.error = null;
            })
            .addCase(readUsers.fulfilled, (state, action) => {
                state.loading = false;
                state.users = action.payload;
            })
            .addCase(readUsers.rejected, (state, action) => {
                state.loading = false;
                state.error = action.payload;
            });

        // Actualizar usuario
        builder
            .addCase(updateUser.pending, (state) => {
                state.loading = true;
                state.error = null;
            })
            .addCase(updateUser.fulfilled, (state, action) => {
                state.loading = false;
                const index = state.users.findIndex((user) => user.id === action.payload.id);
                if (index !== -1) {
                    state.users[index] = action.payload;
                }
            })
            .addCase(updateUser.rejected, (state, action) => {
                state.loading = false;
                state.error = action.payload;
            });

        // Eliminar usuario
        builder
            .addCase(deleteUser.pending, (state) => {
                state.loading = true;
                state.error = null;
            })
            .addCase(deleteUser.fulfilled, (state, action) => {
                state.loading = false;
                state.users = state.users.filter((user) => user.id !== action.payload);
            })
            .addCase(deleteUser.rejected, (state, action) => {
                state.loading = false;
                state.error = action.payload;
            });
    },
});

export default usersSlice.reducer;
```